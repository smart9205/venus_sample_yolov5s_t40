/*
 * sample-Encoder-Joint.c
 *
 * Copyright (C) 2014 Ingenic Semiconductor Co.,Ltd
 *
 * The specific description of all APIs called in this file can be viewed in the header file in the proj/sdk-lv3/include/api/cn/imp/ directory
 *
 * Step.1 System init System initialization
 *		@code
 *			memset(&sensor_info, 0, sizeof(sensor_info));
 *			if(SENSOR_NUM == IMPISP_TOTAL_ONE){
 *				memcpy(&sensor_info[0], &Def_Sensor_Info[0], sizeof(IMPSensorInfo));
 *			} else if(SENSOR_NUM == IMPISP_TOTAL_TWO){
 *				memcpy(&sensor_info[0], &Def_Sensor_Info[0], sizeof(IMPSensorInfo) * 2);
 *			}else if(SENSOR_NUM ==IMPISP_TOTAL_THR){
 *				memcpy(&sensor_info[0], &Def_Sensor_Info[0], sizeof(IMPSensorInfo) * 3)
 *			} //According to the number of sensors, copy the contents of the corresponding size Def_Sensor_Info to sensor_info
 *
 *			ret = IMP_ISP_Open() //Open ISP module
 *			ret = IMP_ISP_SetCameraInputMode(&mode) //If there are multiple sensors (maximum support of three cameras), set the mode to multiple cameras (please ignore if you're single camera)
 *			ret = IMP_ISP_AddSensor(IMPVI_MAIN, &sensor_info[*]) //Add sensor, before this operation the sensor driver has been added to the kernel (IMPVI_MAIN is the main camera, IMPVI_SEC is the second camera, IMPVI_THR is the third camera)
 *			ret = IMP_ISP_EnableSensor(IMPVI_MAIN, &sensor_info[*])	//enable sensor, now sensor starts to output image (IMPVI_MAIN is the main camera, IMPVI_SEC is the second camera, IMPVI_THR is the third camera.)
 *			ret = IMP_System_Init() //System initialization
 *			ret = IMP_ISP_EnableTuning() //enable ISP tuning, the ISP debugging interface can then be called
 *		@endcode
 * Step.2 FrameSource init Framesource initialization
 *		@code
 *			ret = IMP_FrameSource_CreateChn(chn[i].index, &chn[i].fs_chn_attr) //Create channel
 *			ret = IMP_FrameSource_SetChnAttr(chn[i].index, &chn[i].fs_chn_attr) //Set channel-related properties, including: image width, image height, image format, output frame rate of the channel, number of cache buf, cropping and scaling properties
 *		@endcode
 * Step.3 Encoder init Encoding initialization
 *		@code
 *			ret = IMP_Encoder_CreateGroup(chn[i].index) //Create coding group
 *			ret = IMP_Encoder_SetDefaultParam(&channel_attr, chn[i].payloadType, S_RC_METHOD, imp_chn_attr_tmp->picWidth, imp_chn_attr_tmp->picHeight, imp_chn_attr_tmp->outFrmRateNum,
 *											imp_chn_attr_tmp->outFrmRateDen, imp_chn_attr_tmp->outFrmRateNum * 2 / imp_chn_attr_tmp->outFrmRateDen, 2,
 *											(S_RC_METHOD == IMP_ENC_RC_MODE_FIXQP) ? 35 : -1, uTargetBitRate) //Set the encoding chnnel default property
 *			ret = IMP_Encoder_CreateChn(chnNum, &channel_attr) //Create encoding chnnel
 *			ret = IMP_Encoder_RegisterChn(chn[i].index, chnNum) //Register the code Channel to the Group
 *		@endcode
 * Step.4 Bind Bind a framesource and encode channel
 *		@code
 *			ret = IMP_System_Bind(&chn[i].framesource_chn, &chn[i].imp_encoder)	//Bind the framesource and the encoded chnnel, and the data generated by the framesource can be automatically transmitted to the encoded chnnel after the binding is successful
 *		@endcode
 * Step.5 Stream On Enable Framesource chnnelï¼Œ start outputting the image
 *		@code
 *			ret = IMP_FrameSource_EnableChn(chn[i].index) //Enable channel, channel starts outputting the image
 *		@endcode
 * Step.6 Get stream Obtain the bitstream
 *		@code
 *			ret = IMP_Encoder_StartRecvPic(chnNum) //Encoding channel began to accept images
 *			ret = IMP_Encoder_PollingStream(chnNum, 1000) //Polling the code stream in the encoding channel
 *			ret = IMP_Encoder_GetStream(chnNum, &stream, 1) //Gets the encoding bitstream
 *			ret = save_stream(stream_fd, &stream) //Save the result to an open file descriptor
 *			ret = IMP_Encoder_ReleaseStream(chnNum, &stream) //Release the encoding stream, use it in pairs with the IMP_Encoder_GetStream
 *			ret = IMP_Encoder_StopRecvPic(chnNum) //Encoding channel stop receiving image
 *		@endcode
 * Step.7 Stream Off     disable Framesource chnnel, stop outputting image
 *		@code
 *			ret = IMP_FrameSource_DisableChn(chn[i].index) //disable channel, Channel stops outputting images
 *		@endcode
 * Step.8 UnBind Unbind Framesource and code chnnel
 *		@code
 *			ret = IMP_System_UnBind(&chn[i].framesource_chn, &chn[i].imp_encoder) //Unbind the framesource and encode chnnel
 *		@endcode
 * Step.9 Encoder exit    Encode deinitialization
 *		@code
 *			ret = IMP_Encoder_Query(chnNum, &chn_stat) //Query the encoding channel status
 *			ret = IMP_Encoder_UnRegisterChn(chnNum) //If already registered, unregister the code channel to Group
 *			ret = IMP_Encoder_DestroyChn(chnNum) //destroy encoding chnnel
 *		@endcode
 * Step.10 FrameSource exit Framesource deinitialization
 *		@code
 *			ret = IMP_FrameSource_DestroyChn(chn[i].index) //destory channel
 *		@endcode
 * Step.11 System exit System deinitialization
 *		@code
 *			ret = IMP_ISP_DisableTuning() //disable ISP tuning
 *			ret = IMP_System_Exit() //System deinitialization
 *			ret = IMP_ISP_DisableSensor(IMPVI_MAIN, &sensor_info[*]) //Disable sensor, sensor stops the output image (IMPVI_MAIN is main camera, IMPVI_SEC is second camera, IMPVI_THR is third camera)
 *			ret = IMP_ISP_DelSensor(IMPVI_MAIN, &sensor_info[*]) //Delete sensor (IMPVI_MAIN is main camera, IMPVI_SEC is second camera, IMPVI_THR is third camera)
 *			ret = IMP_ISP_Close() //Close ISP module
 *		@endcode
 * */
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <unistd.h>
#include <math.h>
#include <imp/imp_log.h>
#include <imp/imp_common.h>
#include <imp/imp_system.h>
#include <imp/imp_framesource.h>
#include <imp/imp_encoder.h>

#include "sample-common.h"

#define TAG "Sample-Encoder-video"

extern struct chn_conf chn[];
extern IMPISPCameraInputMode mode;

static const IMPEncoderRcMode S_RC_METHOD = IMP_ENC_RC_MODE_CBR;
static int save_num = 0;
static int save_stream(int fd, IMPEncoderStream *stream)
{
	int ret, i, nr_pack = stream->packCount;

  //IMP_LOG_DBG(TAG, "----------packCount=%d, stream->seq=%u start----------\n", stream->packCount, stream->seq);
	for (i = 0; i < nr_pack; i++) {
	//IMP_LOG_DBG(TAG, "[%d]:%10u,%10lld,%10u,%10u,%10u\n", i, stream->pack[i].length, stream->pack[i].timestamp, stream->pack[i].frameEnd, *((uint32_t *)(&stream->pack[i].nalType)), stream->pack[i].sliceType);
		IMPEncoderPack *pack = &stream->pack[i];
		if(pack->length){
			uint32_t remSize = stream->streamSize - pack->offset;
			if(remSize < pack->length){
				ret = write(fd, (void *)(stream->virAddr + pack->offset), remSize);
				if (ret != remSize) {
					IMP_LOG_ERR(TAG, "stream write ret(%d) != pack[%d].remSize(%d) error:%s\n", ret, i, remSize, strerror(errno));
					return -1;
				}
				ret = write(fd, (void *)stream->virAddr, pack->length - remSize);
				if (ret != (pack->length - remSize)) {
					IMP_LOG_ERR(TAG, "stream write ret(%d) != pack[%d].(length-remSize)(%d) error:%s\n", ret, i, (pack->length - remSize), strerror(errno));
					return -1;
				}
			}else {
				ret = write(fd, (void *)(stream->virAddr + pack->offset), pack->length);
				if (ret != pack->length) {
					IMP_LOG_ERR(TAG, "stream write ret(%d) != pack[%d].length(%d) error:%s\n", ret, i, pack->length, strerror(errno));
					return -1;
				}
			}
		}
	}
  //IMP_LOG_DBG(TAG, "----------packCount=%d, stream->seq=%u end----------\n", stream->packCount, stream->seq);
	return 0;
}

int sample_encoder_joint_init()
{
	int i, ret, chnNum = 0;
    int s32picWidth = 0,s32picHeight = 0;
	IMPFSChnAttr *imp_chn_attr_tmp;
	IMPEncoderChnAttr channel_attr;
    for (i = 0; i <  FS_CHN_NUM; i++) {
        if (chn[i].enable) {
            if(((mode.joint_mode & 0xf) != IMPISP_NOT_JOINT && i == 3) || 
                ((mode.joint_mode  >> 0x4 & 0xf) != IMPISP_NOT_JOINT && i == 1) ||
                ((mode.joint_mode  >> 0xc & 0xf) != IMPISP_NOT_JOINT && i == 4) ||
                ((mode.joint_mode >> 0x8 & 0xf) != IMPISP_NOT_JOINT && i == 4))
                continue;
            imp_chn_attr_tmp = &chn[i].fs_chn_attr;
            chnNum = chn[i].index;

            memset(&channel_attr, 0, sizeof(IMPEncoderChnAttr));

            s32picWidth = chn[i].fs_chn_attr.picWidth;
            s32picHeight =chn[i].fs_chn_attr.picHeight;
			float ratio = 1;
			if (((uint64_t)s32picWidth * s32picHeight) > (1280 * 720)) {
				ratio = log10f(((uint64_t)s32picWidth * s32picHeight) / (1280 * 720.0)) + 1;
			} else {
				ratio = 1.0 / (log10f((1280 * 720.0) / ((uint64_t)s32picWidth * s32picHeight)) + 1);
			}
			ratio = ratio > 0.1 ? ratio : 0.1;
			unsigned int uTargetBitRate = BITRATE_720P_Kbs * ratio;
			printf("rcMode:%d.\n", S_RC_METHOD);
            ret = IMP_Encoder_SetDefaultParam(&channel_attr, chn[i].payloadType, S_RC_METHOD,
                    s32picWidth, s32picHeight,
                    imp_chn_attr_tmp->outFrmRateNum, imp_chn_attr_tmp->outFrmRateDen,
                    imp_chn_attr_tmp->outFrmRateNum * 2 / imp_chn_attr_tmp->outFrmRateDen, 2,
                    (S_RC_METHOD == IMP_ENC_RC_MODE_FIXQP) ? 35 : -1,
                    uTargetBitRate);
            if (ret < 0) {
                IMP_LOG_ERR(TAG, "IMP_Encoder_SetDefaultParam(%d) error !\n", chnNum);
                return -1;
            }
            ret = IMP_Encoder_CreateChn(chnNum, &channel_attr);
            if (ret < 0) {
                IMP_LOG_ERR(TAG, "IMP_Encoder_CreateChn(%d) error !\n", chnNum);
                return -1;
            }

			ret = IMP_Encoder_RegisterChn(chn[i].index, chnNum);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_RegisterChn(%d, %d) error: %d\n", chn[i].index, chnNum, ret);
				return -1;
			}
		}
	}

	return 0;
}

int sample_encoder_joint_exit(void)
{
    int ret = 0, i = 0, chnNum = 0;
    IMPEncoderChnStat chn_stat;

	for (i = 0; i <  FS_CHN_NUM; i++) {
		if (chn[i].enable) {
            if(((mode.joint_mode & 0xf) != IMPISP_NOT_JOINT && i == 3) || 
                ((mode.joint_mode  >> 0x4 & 0xf) != IMPISP_NOT_JOINT && i == 1) ||
                ((mode.joint_mode  >> 0xc & 0xf) != IMPISP_NOT_JOINT && i == 4) ||
                ((mode.joint_mode >> 0x8 & 0xf) != IMPISP_NOT_JOINT && i == 4))
                continue;
            chnNum = chn[i].index;
            memset(&chn_stat, 0, sizeof(IMPEncoderChnStat));
            ret = IMP_Encoder_Query(chnNum, &chn_stat);
            if (ret < 0) {
                IMP_LOG_ERR(TAG, "IMP_Encoder_Query(%d) error: %d\n", chnNum, ret);
                return -1;
            }

			if (chn_stat.registered) {
				ret = IMP_Encoder_UnRegisterChn(chnNum);
				if (ret < 0) {
					IMP_LOG_ERR(TAG, "IMP_Encoder_UnRegisterChn(%d) error: %d\n", chnNum, ret);
					return -1;
				}

				ret = IMP_Encoder_DestroyChn(chnNum);
				if (ret < 0) {
					IMP_LOG_ERR(TAG, "IMP_Encoder_DestroyChn(%d) error: %d\n", chnNum, ret);
					return -1;
				}

                ret = IMP_Encoder_DestroyGroup(chnNum);
				if (ret < 0) {
				    IMP_LOG_ERR(TAG, "IMP_Encoder_DestroyGroup(%d) error: %d\n", chnNum, ret);
					return -1;
                }

			}
		}
	}

	return 0;
}

static void *get_video_stream_joint(void *args)
{
    int val, i, chnNum, ret;
    char stream_path[64];
    IMPEncoderEncType encType;
    int stream_fd = -1, totalSaveCnt = 0;

    val = (int)args;
    chnNum = val & 0xffff;
    encType = (val >> 16) & 0xffff;


    ret = IMP_Encoder_StartRecvPic(chnNum);
    if (ret < 0) {
        IMP_LOG_ERR(TAG, "IMP_Encoder_StartRecvPic(%d) failed\n", chnNum);
        return ((void *)-1);
    }
    //printf("save num %d !\n",save_num);
    sprintf(stream_path, "%s/%d-stream-chn%d-%dx%d.%s", STREAM_FILE_PATH_PREFIX, save_num, chnNum, chn[chnNum].fs_chn_attr.picWidth,chn[chnNum].fs_chn_attr.picHeight,
            (encType == IMP_ENC_TYPE_AVC) ? "h264" : ((encType == IMP_ENC_TYPE_HEVC) ? "h265" : "jpeg"));

    if (encType == IMP_ENC_TYPE_JPEG) {
        totalSaveCnt = ((NR_FRAMES_TO_SAVE / 50) > 0) ? (NR_FRAMES_TO_SAVE / 50) : 1;
    } else {
        IMP_LOG_DBG(TAG, "Video ChnNum=%d Open Stream file %s ", chnNum, stream_path);
        stream_fd = open(stream_path, O_RDWR | O_CREAT | O_TRUNC, 0777);
        if (stream_fd < 0) {
            IMP_LOG_ERR(TAG, "failed: %s\n", strerror(errno));
            return ((void *)-1);
        }
        IMP_LOG_DBG(TAG, "OK\n");
        totalSaveCnt = NR_FRAMES_TO_SAVE;
    }

    for (i = 0; i < totalSaveCnt; i++) {
        ret = IMP_Encoder_PollingStream(chnNum, 1000);
        if (ret < 0) {
            IMP_LOG_ERR(TAG, "IMP_Encoder_PollingStream(%d) timeout\n", chnNum);
            continue;
        }

        IMPEncoderStream stream;
        /* Get H264 or H265 Stream */
        ret = IMP_Encoder_GetStream(chnNum, &stream, 1);
        if (ret < 0) {
            IMP_LOG_ERR(TAG, "IMP_Encoder_GetStream(%d) failed\n", chnNum);
            return ((void *)-1);
        }

        ret = save_stream(stream_fd, &stream);
        if (ret < 0) {
            close(stream_fd);
            return ((void *)ret);
        }
        IMP_Encoder_ReleaseStream(chnNum, &stream);
    }

    close(stream_fd);

    ret = IMP_Encoder_StopRecvPic(chnNum);
    if (ret < 0) {
        IMP_LOG_ERR(TAG, "IMP_Encoder_StopRecvPic(%d) failed\n", chnNum);
        return ((void *)-1);
    }
    IMP_LOG_DBG(TAG, "chn%d save end !", chnNum);

    return ((void *)0);
}


int sample_get_video_stream_joint()
{
	unsigned int i;
	int ret;
	pthread_t tid[FS_CHN_NUM];

	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
            if(((mode.joint_mode & 0xf) != IMPISP_NOT_JOINT && i == 3) || 
                ((mode.joint_mode  >> 0x4 & 0xf) != IMPISP_NOT_JOINT && i == 1) ||
                ((mode.joint_mode  >> 0xc & 0xf) != IMPISP_NOT_JOINT && i == 4) ||
                ((mode.joint_mode >> 0x8 & 0xf) != IMPISP_NOT_JOINT && i == 4))
                continue;
            int arg = 0;
            if (chn[i].payloadType == IMP_ENC_PROFILE_JPEG) {
                arg = (((chn[i].payloadType >> 24) << 16) | (4 + chn[i].index));
            } else {
                arg = (((chn[i].payloadType >> 24) << 16) | chn[i].index);
            }
			ret = pthread_create(&tid[i], NULL, get_video_stream_joint, (void *)arg);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "Create ChnNum%d get_video_stream_joint failed\n", (chn[i].payloadType == IMP_ENC_PROFILE_JPEG) ? (4 + chn[i].index) : chn[i].index);
			}
		}
	}

    for (i = 0; i < FS_CHN_NUM; i++) {
        if (chn[i].enable) {
            if(((mode.joint_mode & 0xf) != IMPISP_NOT_JOINT && i == 3) || 
                ((mode.joint_mode  >> 0x4 & 0xf) != IMPISP_NOT_JOINT && i == 1) ||
                ((mode.joint_mode  >> 0xc & 0xf) != IMPISP_NOT_JOINT && i == 4) ||
                ((mode.joint_mode >> 0x8 & 0xf) != IMPISP_NOT_JOINT && i == 4))
                continue;
            pthread_join(tid[i],NULL);
        }
    }

	return 0;
}

int joint_system()
{
	int i, ret;
    IMP_LOG_DBG(TAG, "%s START !\n",__func__);

	/* Step.2 FrameSource init */
	ret = sample_framesource_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "FrameSource init failed\n");
		return -1;
	}

	/* Step.3 Encoder init */
	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
            if(((mode.joint_mode & 0xf) != IMPISP_NOT_JOINT && i == 3) || 
                ((mode.joint_mode  >> 0x4 & 0xf) != IMPISP_NOT_JOINT && i == 1) ||
                ((mode.joint_mode  >> 0xc & 0xf) != IMPISP_NOT_JOINT && i == 4) ||
                ((mode.joint_mode >> 0x8 & 0xf) != IMPISP_NOT_JOINT && i == 4))
                continue;
			ret = IMP_Encoder_CreateGroup(chn[i].index);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "IMP_Encoder_CreateGroup(%d) error !\n", chn[i].index);
				return -1;
			}
		}
	}

    IMP_LOG_DBG(TAG, "sample_encoder_joint_init START !\n");
	ret = sample_encoder_joint_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Encoder init failed\n");
		return -1;
	}

    IMP_LOG_DBG(TAG, "IMP_System_Bind START !\n");
	/* Step.4 Bind */
	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
            if(((mode.joint_mode & 0xf) != IMPISP_NOT_JOINT && i == 3) || 
                ((mode.joint_mode  >> 0x4 & 0xf) != IMPISP_NOT_JOINT && i == 1) ||
                ((mode.joint_mode  >> 0xc & 0xf) != IMPISP_NOT_JOINT && i == 4) ||
                ((mode.joint_mode >> 0x8 & 0xf) != IMPISP_NOT_JOINT && i == 4))
                continue;
			ret = IMP_System_Bind(&chn[i].framesource_chn, &chn[i].imp_encoder);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "Bind FrameSource channel%d and Encoder failed\n",i);
				return -1;
			}
		}
	}

    IMP_LOG_DBG(TAG, "sample_framesource_streamon START !\n");
	/* Step.5 Stream On */
	ret = sample_framesource_streamon();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "ImpStreamOn failed\n");
		return -1;
	}

    IMP_LOG_DBG(TAG, "sample_get_video_stream_joint START !\n");
	/* Step.6 Get stream */
    ret = sample_get_video_stream_joint();
    if (ret < 0) {
        IMP_LOG_ERR(TAG, "Get video stream failed\n");
        return -1;
    }

	/* Exit sequence as follow */
	/* Step.a Stream Off */
    IMP_LOG_DBG(TAG, "sample_framesource_streamoff START !\n");
	ret = sample_framesource_streamoff();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "FrameSource StreamOff failed\n");
		return -1;
	}

	/* Step.b UnBind */
    IMP_LOG_DBG(TAG, "IMP_System_UnBind START !");
	for (i = 0; i < FS_CHN_NUM; i++) {
		if (chn[i].enable) {
            if(((mode.joint_mode & 0xf) != IMPISP_NOT_JOINT && i == 3) || 
                ((mode.joint_mode  >> 0x4 & 0xf) != IMPISP_NOT_JOINT && i == 1) ||
                ((mode.joint_mode  >> 0xc & 0xf) != IMPISP_NOT_JOINT && i == 4) ||
                ((mode.joint_mode >> 0x8 & 0xf) != IMPISP_NOT_JOINT && i == 4))
                continue;
			ret = IMP_System_UnBind(&chn[i].framesource_chn, &chn[i].imp_encoder);
			if (ret < 0) {
				IMP_LOG_ERR(TAG, "UnBind FrameSource channel%d and Encoder failed\n",i);
				return -1;
			}
		}
	}

	/* Step.c Encoder exit */
    IMP_LOG_DBG(TAG, "sample_encoder_joint_exit START !\n");
	ret = sample_encoder_joint_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Encoder exit failed\n");
		return -1;
	}

	/* Step.d FrameSource exit */
    IMP_LOG_DBG(TAG, "sample_framesource_exit START !\n");
	ret = sample_framesource_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "FrameSource exit failed\n");
		return -1;
	}

    IMP_LOG_DBG(TAG, "%s END !\n",__func__);

    return 0;
}

extern IMPSensorInfo sensor_info[3];
int joint_system_init()
{
	int ret = 0;

	ret = IMP_ISP_Open();
	if(ret < 0){
		IMP_LOG_ERR(TAG, "failed to open ISP\n");
		return -1;
	}

	/* set dual sensor mode */
	if(mode.sensor_num > IMPISP_TOTAL_ONE){
		ret = IMP_ISP_SetCameraInputMode(&mode);
		if(ret < 0){
			IMP_LOG_ERR(TAG, "failed to camera input mode!\n");
			return -1;
		}
	}

	/* add sensor */
	ret = IMP_ISP_AddSensor(IMPVI_MAIN, &sensor_info[0]);
	if(ret < 0){
		IMP_LOG_ERR(TAG, "failed to AddSensor\n");
		return -1;
	}

	if(mode.sensor_num > IMPISP_TOTAL_ONE){
		ret = IMP_ISP_AddSensor(IMPVI_SEC, &sensor_info[1]);
		if(ret < 0){
			IMP_LOG_ERR(TAG, "failed to AddSensor\n");
			return -1;
		}
	}

	if(mode.sensor_num > IMPISP_TOTAL_TWO){
		ret = IMP_ISP_AddSensor(IMPVI_THR, &sensor_info[2]);
		if(ret < 0){
			IMP_LOG_ERR(TAG, "failed to AddSensor\n");
			return -1;
		}
	}

	/* enable sensor */
	ret = IMP_ISP_EnableSensor(IMPVI_MAIN, &sensor_info[0]);
	if(ret < 0){
		IMP_LOG_ERR(TAG, "failed to EnableSensor\n");
		return -1;
	}

	if(mode.sensor_num > IMPISP_TOTAL_ONE){
		ret = IMP_ISP_EnableSensor(IMPVI_SEC, &sensor_info[1]);
		if(ret < 0){
			IMP_LOG_ERR(TAG, "failed to EnableSensor\n");
			return -1;
		}
	}

	if(mode.sensor_num > IMPISP_TOTAL_TWO){
		ret = IMP_ISP_EnableSensor(IMPVI_THR, &sensor_info[2]);
		if(ret < 0){
			IMP_LOG_ERR(TAG, "failed to EnableSensor\n");
			return -1;
		}

	}

	/* enable turning, to debug graphics */
	ret = IMP_ISP_EnableTuning();
	if(ret < 0){
		IMP_LOG_ERR(TAG, "IMP_ISP_EnableTuning failed\n");
		return -1;
	}

	IMPISPRunningMode dn = IMPISP_RUNNING_MODE_DAY;
	ret = IMP_ISP_Tuning_SetISPRunningMode(IMPVI_MAIN, &dn);
	if (ret < 0){
		IMP_LOG_ERR(TAG, "failed to set running mode\n");
		return -1;
	}

	if(mode.sensor_num > IMPISP_TOTAL_ONE){
		ret = IMP_ISP_Tuning_SetISPRunningMode(IMPVI_SEC, &dn);
		if (ret < 0){
			IMP_LOG_ERR(TAG, "failed to set running mode\n");
			return -1;
		}
	}

#if 1
	uint32_t fps_num = 15;
	uint32_t fps_den = 1;
	ret = IMP_ISP_Tuning_SetSensorFPS(0, &fps_num, &fps_den);
	ret = IMP_ISP_Tuning_SetSensorFPS(1, &fps_num, &fps_den);
    if (ret < 0){
        IMP_LOG_ERR(TAG, "failed to set sensor fps\n");
        return -1;
    }
#endif
    save_num++;

	IMP_LOG_DBG(TAG, "ImpSystemInit success\n");

	return 0;
}

int joint_system_exit()
{
	int ret = 0;

	IMP_LOG_DBG(TAG, "sample_system_exit start\n");



	/* disable sensor */
	ret = IMP_ISP_DisableSensor(IMPVI_MAIN);
	if(ret < 0){
		IMP_LOG_ERR(TAG, "failed to EnableSensor\n");
		return -1;
	}

	if(mode.sensor_num > IMPISP_TOTAL_ONE){
		ret = IMP_ISP_DisableSensor(IMPVI_SEC);
		if(ret < 0){
			IMP_LOG_ERR(TAG, "failed to EnableSensor\n");
			return -1;
		}
	}

	if(mode.sensor_num > IMPISP_TOTAL_TWO){
		ret = IMP_ISP_DisableSensor(IMPVI_THR);
		if(ret < 0){
			IMP_LOG_ERR(TAG, "failed to EnableSensor\n");
			return -1;
		}
	}

	/* delete sensor */
	ret = IMP_ISP_DelSensor(IMPVI_MAIN, &sensor_info[0]);
	if(ret < 0){
		IMP_LOG_ERR(TAG, "failed to AddSensor\n");
		return -1;
	}

	if(mode.sensor_num > IMPISP_TOTAL_ONE){
		ret = IMP_ISP_DelSensor(IMPVI_SEC, &sensor_info[1]);
		if(ret < 0){
			IMP_LOG_ERR(TAG, "failed to AddSensor\n");
			return -1;
		}
	}

	if(mode.sensor_num > IMPISP_TOTAL_TWO){
		ret = IMP_ISP_DelSensor(IMPVI_THR, &sensor_info[2]);
		if(ret < 0){
			IMP_LOG_ERR(TAG, "failed to AddSensor\n");
			return -1;
		}
	}

	/* disable turning */
	ret = IMP_ISP_DisableTuning();
	if(ret < 0){
		IMP_LOG_ERR(TAG, "IMP_ISP_DisableTuning failed\n");
		return -1;
	}

	if(IMP_ISP_Close()){
		IMP_LOG_ERR(TAG, "failed to open ISP\n");
		return -1;
	}

	IMP_LOG_DBG(TAG, " sample_system_exit success\n");

	return 0;
}

void set_joint_res(int mwidth, int mheight, int swidth, int sheight, int joint_mode)
{
    mode.joint_mode = joint_mode;

	chn[0].fs_chn_attr.scaler.enable = 1;
	chn[0].fs_chn_attr.scaler.outwidth = mwidth;
	chn[0].fs_chn_attr.scaler.outheight = mheight;
    if((joint_mode & 0xf) == IMPISP_MAIN_ON_THE_LEFT || 
        (joint_mode & 0xf) == IMPISP_MAIN_ON_THE_RIGHT || 
        (joint_mode >> 0x4 & 0xf) == IMPISP_MAIN_ON_THE_LEFT || 
        (joint_mode >> 0x4 & 0xf) == IMPISP_MAIN_ON_THE_RIGHT){
	    chn[0].fs_chn_attr.picWidth = mwidth * 2;
    } else {
	    chn[0].fs_chn_attr.picWidth = mwidth;
    }
    if((joint_mode & 0xf) == IMPISP_MAIN_ON_THE_ABOVE || 
        (joint_mode & 0xf) == IMPISP_MAIN_ON_THE_UNDER || 
        (joint_mode >> 4 & 0xf) == IMPISP_MAIN_ON_THE_ABOVE || 
        (joint_mode >> 4 & 0xf) == IMPISP_MAIN_ON_THE_UNDER){
	    chn[0].fs_chn_attr.picHeight =  mheight * 2;
    } else {
	    chn[0].fs_chn_attr.picHeight =  mheight;
    }

	chn[1].fs_chn_attr.scaler.enable = 1;
    if((joint_mode & 0xf0) != IMPISP_NOT_JOINT){
        chn[1].fs_chn_attr.scaler.outwidth = mwidth;
        chn[1].fs_chn_attr.scaler.outheight = mheight;
        chn[1].fs_chn_attr.picWidth = mwidth;
        chn[1].fs_chn_attr.picHeight =  mheight;
    }else{
        chn[1].fs_chn_attr.scaler.outwidth = swidth;
        chn[1].fs_chn_attr.scaler.outheight = sheight;
        if((joint_mode >> 0x8 & 0xf) == IMPISP_MAIN_ON_THE_LEFT || (joint_mode >> 0x8 & 0xf) == IMPISP_MAIN_ON_THE_RIGHT){
            chn[1].fs_chn_attr.picWidth = swidth * 2;
        } else {
            chn[1].fs_chn_attr.picWidth = swidth;
        }
        if((joint_mode >> 0x8 & 0xf) == IMPISP_MAIN_ON_THE_ABOVE || (joint_mode >> 0x8 & 0xf) == IMPISP_MAIN_ON_THE_UNDER){
            chn[1].fs_chn_attr.picHeight =  sheight * 2;
        } else {
            chn[1].fs_chn_attr.picHeight =  sheight;
        }
    }


	chn[3].fs_chn_attr.scaler.enable = 1;
	chn[3].fs_chn_attr.scaler.outwidth = mwidth;
	chn[3].fs_chn_attr.scaler.outheight = mheight;
    if((joint_mode >> 0xc & 0xf) == IMPISP_MAIN_ON_THE_LEFT || (joint_mode >> 0xc & 0xf) == IMPISP_MAIN_ON_THE_RIGHT){
        chn[3].fs_chn_attr.picWidth = mwidth * 2;
    } else {
        chn[3].fs_chn_attr.picWidth = mwidth;
    }

    if((joint_mode >> 0xc & 0xf) == IMPISP_MAIN_ON_THE_ABOVE || (joint_mode >> 0xc & 0xf) == IMPISP_MAIN_ON_THE_UNDER){
        chn[3].fs_chn_attr.picHeight =  mheight * 2;
    } else {
        chn[3].fs_chn_attr.picHeight = mheight;
    }

    chn[4].fs_chn_attr.scaler.enable = 1;
    if((joint_mode & 0xf000) != IMPISP_NOT_JOINT){
        chn[4].fs_chn_attr.scaler.outwidth = mwidth;
        chn[4].fs_chn_attr.scaler.outheight = mheight;
        chn[4].fs_chn_attr.picWidth = mwidth;
        chn[4].fs_chn_attr.picHeight =  mheight;
    }else{
        chn[4].fs_chn_attr.scaler.outwidth = swidth;
        chn[4].fs_chn_attr.scaler.outheight = sheight;
        chn[4].fs_chn_attr.picWidth = swidth;
        chn[4].fs_chn_attr.picHeight =  sheight;
    }

}

int main(int argc, char *argv[])
{
	int ret;


	/* Step.1 System init */
    //No joint
    //0
    set_joint_res(1920, 1080, 1280, 720, IMPISP_NOT_JOINT);
	ret = sample_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "IMP_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}

#if 1
    //fs0 + fs3 joint vertically, fs0 on top; fs1 + fs4 no joint
    //1
    set_joint_res(1280, 720, 1280, 720, IMPISP_MAIN_ON_THE_ABOVE);
    ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}

    //fs1 + fs4 joint vertically, fs1 on top; fs0 + fs3 no joint
    //2
    set_joint_res(640, 360, 1280, 720, IMPISP_SEC_14_ON_THE_ABOVE);
    ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}
    
    //fs1 + fs4 joint vertically, fs1 on top; fs0 + fs3 joint vertically, fs0 at bottom
    //3
    set_joint_res(1920, 1080, 1280, 720, IMPISP_SEC_14_ON_THE_ABOVE | IMPISP_MAIN_ON_THE_UNDER);
    ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}

    //fs1 + fs4 joint horizontally, f1 on left; fs0 + fs3 joint horizontally, fs0 on right
    //4
    set_joint_res(1920, 1080, 1280, 720, IMPISP_SEC_14_ON_THE_LEFT | IMPISP_MAIN_ON_THE_RIGHT);
    ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}

    //fs1 + fs4 joint horizontally, f1 on left; fs0 + fs3 joint vertically, fs0 on top
    //5
    set_joint_res(1920, 1080, 1280, 720, IMPISP_SEC_14_ON_THE_LEFT | IMPISP_MAIN_ON_THE_ABOVE);
    ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}

    //fs1 + fs4 vertically joint, f1 on top; fs0 + fs3 horizontally joint, fs0 on the right
    //6
    set_joint_res(1920, 1080, 1280, 720, IMPISP_SEC_14_ON_THE_ABOVE| IMPISP_MAIN_ON_THE_RIGHT);
    ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}
    
    //fs0 + fs1 horizontally joint, f0 on the left; fs3 + fs4 horizontally joint, fs3 on the right
    //7
    set_joint_res(1920, 1080, 1280, 720, IMPISP_MAIN_01_ON_THE_LEFT | IMPISP_SEC_34_ON_THE_RIGHT);
    ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}

    //fs0 + fs1 vertically joint, f0 on top; fs3 + fs4 horizontally joint, fs3 on the left
    //8
    set_joint_res(1920, 1080, 1280, 720, IMPISP_MAIN_01_ON_THE_ABOVE | IMPISP_SEC_34_ON_THE_LEFT);
    ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}
#endif
    
    //fs0 + fs1 vertically joint, f0 on the bottom; fs3 + fs4 vertically joint, fs3 on top
    //9
    set_joint_res(1920, 1080, 1280, 720, IMPISP_MAIN_01_ON_THE_UNDER | IMPISP_SEC_34_ON_THE_ABOVE);
    ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
    ret = joint_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System_Exit() failed\n");
		return -1;
	}
    
    //No joint
    //10
    set_joint_res(1920, 1080, 1280, 720, IMPISP_NOT_JOINT);
	ret = joint_system_init();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "IMP_System_Init() failed\n");
		return -1;
	}
    ret = joint_system();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "Joint_System() failed\n");
		return -1;
	}
	/* Step.e System exit */
	ret = sample_system_exit();
	if (ret < 0) {
		IMP_LOG_ERR(TAG, "sample_system_exit() failed\n");
		return -1;
	}

	return 0;
}
